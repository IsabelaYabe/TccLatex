\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Idioma e tipografia
\usepackage[brazilian]{babel}
\usepackage{csquotes}
\usepackage{lmodern}
\usepackage{microtype}

% Layout e recursos básicos
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}

\emergencystretch=2em
\cleardoublepage
\pagenumbering{arabic}

% Matemática e teoremas (essencial só se você usa)
\usepackage{amsmath,amssymb,amsthm}

% Tabelas em paisagem e colunas flexíveis
% \usepackage{pdflscape}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{ragged2e}
\usepackage{array} % para \newcolumntype
\newcolumntype{Y}{>{\RaggedRight\arraybackslash}X}
\usepackage{rotating} % para sidewaystable/sideways


% Bibliografia ABNT numerada
\usepackage[
  backend=biber,
  style=abnt,
  sorting=none,
  giveninits=true,
  uniquename=false,
  doi=false,
  isbn=false,
  url=false,
  language=brazil,
  scbib,
  ittitles,
  justify
]{biblatex}
\addbibresource{refs.bib} % ← caminho corrigido



% ======= PADRONIZAÇÃO PARA A TABELA MDRE =======

% Coluna flexível "Y" (se ainda não tiver)
% \usepackage{tabularx,booktabs,ragged2e,array}
% \newcolumntype{Y}{>{\RaggedRight\arraybackslash}X}

% 1) Vocabulário controlado (sempre em SMALL CAPS):
% force medium series inside \textsc to avoid requesting a bold small-caps font (bx/sc)
\newcommand{\Static}{{\mdseries\textsc{Estático}}}
\newcommand{\Dynamic}{{\mdseries\textsc{Dinâmico}}}
\newcommand{\Hybrid}{{\mdseries\textsc{Híbrido}}}
\newcommand{\Comp}{{\mdseries\textsc{Compreensão}}}
\newcommand{\Redoc}{{\mdseries\textsc{Redocumentação}}}
\newcommand{\Mig}{{\mdseries\textsc{Migração}}}
\newcommand{\Quali}{{\mdseries\textsc{Qualidade}}}

% 2) Macros para setas e encadeamentos:
\newcommand{\ctoa}{\(\text{Código} \rightarrow \text{AST}\)}
\newcommand{\atoxi}{\(\text{AST} \rightarrow \text{IM}\)}   % IM = modelo intermediário
\newcommand{\imtoxml}{\(\text{IM} \rightarrow \text{XML}\)}
\newcommand{\imtomdl}{\(\text{IM} \rightarrow \text{UML}\)}
\newcommand{\tmtomdl}{\(\text{T2M/M2M} \rightarrow \text{UML}\)}
\newcommand{\xtoSeq}{\(\rightarrow \text{UML Sequência}\)}
\newcommand{\xtoClass}{\(\rightarrow \text{UML Classe}\)}
\newcommand{\xtoAct}{\(\rightarrow \text{UML Atividade}\)}

% 3) Abreviações de ferramentas (consistentes):
\newcommand{\EMF}{Eclipse/EMF}
\newcommand{\UMLtwo}{UML2}
\newcommand{\PlantUML}{PlantUML}
\newcommand{\JavaParser}{JavaParser}

% 4) Formato da célula “Aspecto”: Técnica ; Objetivo(s)
%    Ex.: \Static; \Comp/\Redoc (estrutura + comportamento)

% 5) Formato da célula “Técnica/Transformação”:
%    Use sempre cadeia com “→”, negrite elementos-chaves e padronize nomes.
%    Ex.: Código → AST → \textbf{IM(XML)} → T2M/M2M → \textbf{UML2}
%
% 6) Formato da célula “Validação”:
%    [tipo de evidência; dataset/projetos; métrica(s) ou avaliação; nota curta]
%    Ex.: OSS (9 projetos, 2640 classes); AUC=0.73; custo de rótulo 10%

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{0cm}
        
            \includegraphics[width=0.5\textwidth]{Images/Logo_FGV.png} 
            
        \vspace{1.5cm}
        \large
        
        Ciência de Dados e I.A.\\
        Escola de Matemática Aplicada\\
        Fundação Getúlio Vargas\\

        \vspace{1cm}  
    
        \Large
        Engenharia de Requisitos
            
        \vspace{2cm}
        
        \vspace{0.25cm}

        \Huge \textbf{Implementação da AST} \\ 
        \vspace{0.5cm}
        \huge \textbf{LLM para Engenharia de Requisitos}
        \vspace{3.6cm}
        
        \large
                Aluno: Isabela Yabe\\
                Orientador: Rafael de Pinho André\\
                Escola de Matemática Aplicada, FGV/EMAp \\
                Rio de Janeiro - RJ.
        \vfill
            
        \vspace{0.8cm}  
        
        Rio de Janeiro, 2025
            
    \end{center}
\end{titlepage}
\newpage
\pagenumbering{roman}
\tableofcontents

\newpage
\pagenumbering{arabic}

\section{Implementação da Ferramenta de Análise Estática}

% =========================================================
% 1. Visão geral da solução
% =========================================================
\subsection{Visão geral da solução}

Para viabilizar o uso do núcleo de análise estática em diferentes experimentos, foi desenvolvida uma API que encapsula todo o fluxo de construção da AST do Python, aplicação dos \emph{passes} e exportação dos nós enriquecidos em um formato serializável. Essa API expõe uma função de alto nível, \texttt{run\_ast\_analysis}, que recebe um diretório ou arquivo como entrada, executa a análise e retorna uma estrutura \texttt{AnalysisResult} contendo, para cada arquivo, o contexto de análise e a lista de \texttt{TNode}s gerados.

A API é construída sobre duas abstrações centrais: o contexto de análise (\texttt{Ctx}) e o nó sintático enriquecido (\texttt{TNode}). O contexto mantém informações globais do arquivo em processamento (pilhas de classes e funções, linhas de código, comentários por linha, caminhos de arquivo e um espaço de \emph{scratch} compartilhado entre passes). Já o \texttt{TNode} encapsula o nó original da AST do Python (\texttt{ast.AST}) e agrega campos derivados por diferentes passes, como informações de caminho (\emph{path info}), nomes e visibilidade, convenções de nomenclatura, tipo de método, assinatura de entrada/saída, tipo de classe, comentários e docstrings, além de métricas de grafo de chamadas (fan-in, fan-out, chamadores e chamados).

Com essa API, a construção de uma AST enriquecida deixa de ser um procedimento ad hoc e passa a ser uma operação reprodutível e configurável: basta apontar a função de alto nível para o repositório de código alvo e selecionar a estratégia de travessia e o conjunto de plugins desejados. Isso facilita a integração da análise sintática com os experimentos de extração de casos de uso, geração de embeddings e demais tarefas de engenharia de software apoiadas por aprendizado de máquina.

% =========================================================
% 2. Organização dos módulos
% =========================================================
\subsection{Organização dos módulos da ferramenta}

A implementação foi estruturada como um pequeno \emph{microkernel} de análise estática, separando a infraestrutura genérica da lógica específica de cada \emph{pass}. O núcleo está concentrado no pacote \texttt{astcore}, enquanto os passes concretos são fornecidos por um pacote de plugins (\texttt{pass\_plugins}), que pode ser estendido sem modificar o núcleo.

O pacote \texttt{astcore} agrupa os componentes centrais da arquitetura:

\begin{itemize}
    \item \textbf{\texttt{astcore.model}}: contém as definições de \texttt{Ctx} e \texttt{TNode}, que formam o modelo intermediário, além de tipos auxiliares utilizados para representar o resultado da análise.

    \item \textbf{\texttt{astcore.pass\_registry}}: implementa o mecanismo de registro e orquestração dos passes. Esse módulo define a estrutura \texttt{PassSpec}, o registrador central (\texttt{PassRegistry}) e o decorador \texttt{@register\_pass}, utilizado pelos plugins para declarar nome, fase, ordem, dependências e tipos de nó atendidos por cada pass.
    
    \item \textbf{\texttt{astcore.phase}}: define o enumerado \texttt{Phase}, que organiza a execução dos passes em fases lógicas (\texttt{PRE}, \texttt{ENRICH}, \texttt{POST}). Essa enumeração é usada pelo registrador de passes para controlar a ordem global de execução.

    \item \textbf{\texttt{astcore.traversal}}: define as estratégias de travessia da AST, como pré-ordem recursiva, pós-ordem, versões iterativas e busca em largura. Cada estratégia implementa uma interface comum, permitindo escolher o padrão de visita mais adequado sem alterar os passes.

    \item \textbf{\texttt{astcore.strategy\_factory}}: fornece uma \emph{factory} que instancia a estratégia de travessia a partir de um identificador simbólico (por exemplo, \texttt{"preorder"} ou \texttt{"bfs"}). Isso desacopla o código cliente da implementação concreta de cada estratégia.

    \item \textbf{\texttt{astcore.walker}}: implementa o \emph{walker} genérico
    (\texttt{walk\_module}) responsável por percorrer a AST, criar um \texttt{TNode} para cada nó visitado e invocar, em cada fase, os passes registrados e aplicáveis àquele tipo sintático. Esse módulo conecta, na prática, a travessia, o modelo intermediário e o registrador de passes.
\end{itemize}

Sobre esse núcleo, a camada de plugins é organizada no pacote \texttt{pass\_plugins}.
O módulo \texttt{pass\_plugins.loader} implementa o carregamento dinâmico de plugins:
dada uma lista de nomes de módulos, ele realiza as \emph{imports} correspondentes e
invoca, em cada um, uma função de inicialização responsável por registrar os passes
junto ao \texttt{PassRegistry}. Isso permite estender a ferramenta apenas adicionando
novos módulos de passes, sem alterar o código do núcleo.

O conjunto de passes padrão é fornecido pelo subpacote \texttt{pass\_plugins.builtin},
que agrupa os arquivos responsáveis por preencher os diferentes blocos do
\texttt{TNode}. Entre eles, destacam-se:

\begin{itemize}
    \item \textbf{\texttt{path\_info}}: preenche os campos de localização do nó no projeto (\texttt{file\_path}, \texttt{rel\_path}, \texttt{dir\_path}, \texttt{package}, \texttt{module}, \texttt{depth}, \texttt{ext}).

    \item \textbf{\texttt{names\_visibility}}: identifica se o nó representa classes ou métodos, extrai o nome simples e o nome qualificado. Os campos preenchidos incluem \texttt{is\_class}, \texttt{is\_method}, \texttt{name}, \texttt{qname}, \texttt{decorators} e \texttt{visibility}, com base em convenções de nomenclatura (prefixos \texttt{\_} e \texttt{\_\_}).

    \item \textbf{\texttt{naming}}: decompõe identificadores em \emph{tokens} léxicos e classifica o estilo de nomenclatura, preenchendo o bloco \emph{naming} do \texttt{TNode}.

    \item \textbf{\texttt{method\_kind}}: classifica métodos em instância, estáticos, de classe ou propriedades, com base em decoradores e no contexto de classe.

    \item \textbf{\texttt{io\_signature}}: extrai a assinatura de entrada e saída de funções e métodos, incluindo parâmetros, anotação de retorno, uso de geradores, exceções levantadas e expressões de retorno.
 
    \item \textbf{\texttt{class\_kind}}: analisa bases, metaclasse e decoradores de classes para identificar \texttt{@dataclass}, \texttt{@final}, enums e para classificá-las em \emph{concrete}, \emph{abstract} ou \emph{protocol}.

    \item \textbf{\texttt{docs\_comments}}: integra informações da AST com o índice de comentários mantido no \texttt{Ctx}, preenchendo docstrings, blocos de comentários de cabeçalho e comentários internos, além de alimentar o mapa global \texttt{docstrings\_by\_qname}.

    \item \textbf{\texttt{core\_nodes}}: marca, por meio dos campos \texttt{is\_core} e \texttt{core\_kind}, os nós considerados centrais na representação reduzida da AST (escopos, atribuições, chamadas, retornos e lançamentos de exceção).

    \item \textbf{\texttt{call\_graph}}: constrói o grafo de chamadas entre funções e métodos em duas etapas: primeiro coleta as chamadas locais e acumula arestas e nós chamáveis no \texttt{scratch}; depois, em uma fase posterior, resolve chamadores e chamados e preenche as métricas de \emph{fan-in} e \emph{fan-out} de cada \texttt{TNode}.
\end{itemize}

Essa organização modular separa claramente as responsabilidades entre o núcleo
genérico de análise e os passes especializados. Novas dimensões de enriquecimento
podem ser adicionadas simplesmente criando módulos adicionais em \texttt{pass\_plugins}
e registrando seus passes, preservando a arquitetura do microkernel e a
reprodutibilidade dos experimentos.

\subsubsection{Núcleo \texttt{astcore}}

O núcleo \texttt{astcore} implementa a infraestrutura central do microkernel de análise estática. Sua função é fornecer os componentes genéricos e reutilizáveis responsáveis por modelar o contexto de análise e os nós enriquecidos (\texttt{Ctx} e \texttt{TNode} - astcore.model), organizar a execução dos passes por meio das fases (\texttt{Phase} - astcore.phase), registrar e ordenar passes com base em dependências declarativas (\texttt{PassRegistry} - astcore.pass\_registry), definir múltiplas estratégias de travessia da AST (\texttt{traversal} - astcore.traversal) e expor uma fábrica para seleção dessas estratégias (\texttt{strategy\_factory} - astcore.strategy\_factory). Esses elementos são integrados pelo módulo \texttt{walker}, responsável por percorrer a AST, criar instâncias de \texttt{TNode} e aplicar, em cada fase, os passes registrados (astcore.walker). 

\paragraph{\texttt{astcore.model}.}

% TODO:
%  - Explicar que contém Ctx e TNode (referenciar subseção detalhada mais adiante).
%  - Mencionar que TNode é a representação intermediária e que Ctx armazena estado global.

\paragraph{\texttt{astcore.phase}.}

% TODO:
%  - Definir as fases (PRE, ENRICH, POST).
%  - Explicar rapidamente como elas estruturam o pipeline de passes.

\paragraph{\texttt{astcore.pass\_registry}.}

O módulo \texttt{astcore.pass\_registry} implementa o microkernel de orquestração dos \emph{passes} de análise. Cada \emph{pass} é descrito pela estrutura \texttt{PassSpec}, que associa a função de processamento (\texttt{fn}) a um conjunto de metadados: index ordenado (\texttt{sort\_index}), nome (\texttt{name}), fase de execução (\texttt{phase}), prioridade relativa dentro da fase (\texttt{order}), dependências declaradas (\texttt{requires}), tipos de nó da AST aos quais se aplica (\texttt{node\_types}) e a lista de campos do \texttt{TNode} que ele garante preencher (\texttt{provides}). Um predicado opcional (\texttt{when}) permite restringir dinamicamente os nós para os quais o \emph{pass} deve ser executado.

Além de armazenar metadados, o \texttt{PassSpec} executa um conjunto de validações
estruturais diretamente no método \texttt{\_\_post\_init\_\_}, o que impede que o pipeline
seja inicializado com configurações inválidas. 

A estrutura \texttt{PassRegistry} mantém o catálogo global de \emph{passes}, organizado por fase de execução. Internamente, o registrador mantém (i) um índice por nome, que permite consultar rapidamente um \texttt{PassSpec}, e (ii) uma lista por fase (\texttt{PRE}, \texttt{ENRICH}, \texttt{POST}) com todos os \emph{passes} declarados para aquela etapa. Quando um novo \emph{pass} é registrado, o registrador verifica se o nome já foi utilizado, adiciona o \texttt{PassSpec} na fase apropriada e mantém a lista ordenada pelo par (\texttt{order}, \texttt{name}), garantindo uma ordenação.

Para compor a ordem final de execução, o \texttt{PassRegistry} oferece um método de ordenção topológica (\texttt{topological}) que recebe o conjunto de \texttt{PassSpec}s de uma fase, valida se todas as dependências (\texttt{requires}) estão presentes e, em seguida, constrói um grafo de precedência entre \emph{passes}. A ordenação é calculada por uma variante do algoritmo de Kahn, combinada com uma fila de prioridade: a cada passo, são selecionados apenas \emph{passes} cujas dependências já foram satisfeitas, priorizando aqueles de menor \texttt{order} e, em caso de empate, de menor \texttt{name}. Se, ao final do processo, ainda existirem \emph{passes} com dependências não resolvidas, o registrador sinaliza um ciclo de dependência entre \emph{passes}, impedindo a execução do pipeline em um estado inconsistente.

Por fim, o módulo expõe um decorador de conveniência, \texttt{@register\_pass}, utilizado pelos plugins para declarar novos \emph{passes}. Esse decorador recebe, como argumentos, os metadados do \emph{pass} (nome, fase, ordem, dependências, tipos de nó e campos \texttt{provides}) e registra automaticamente a função alvo no \texttt{PassRegistry} global. Dessa forma, basta importar o módulo de plugins para que seus \emph{passes} sejam visíveis ao núcleo de análise, sem necessidade de código adicional de configuração.


\paragraph{\texttt{astcore.traversal}.}

% TODO:
%  - Descrever as estratégias de travessia (pré-ordem, pós-ordem, BFS/iterativa).
%  - Citar que todas implementam a mesma interface.

\paragraph{\texttt{astcore.strategy\_factory}.}

% TODO:
%  - Explicar que escolhe a estratégia a partir de um identificador (string).
%  - Comentar que isso desacopla o código cliente da implementação.

\paragraph{\texttt{astcore.walker}.}

% TODO:
%  - Descrever o walk_module (ou equivalente).
%  - Explicar em alto nível: 
%    * percorre AST usando estratégia,
%    * cria TNodes,
%    * roda passes por fase.

% ------------------------------
\subsubsection{Camada de plugins \texttt{pass\_plugins}}

\paragraph{\texttt{pass\_plugins.loader}.}

% TODO:
%  - Explicar como o loader importa dinamicamente os módulos.
%  - Comentar sobre a função initialize() que registra passes no PassRegistry.
%  - Ligar isso com a lista de plugins configurável.

\paragraph{Passes padrão em \texttt{pass\_plugins.builtin}.}

% TODO:
%  - 1 parágrafo geral explicando que esses são os passes "de fábrica",
%    responsáveis por preencher cada bloco do TNode.
%  - Depois você detalha cada pass na subseção seguinte.


% =========================================================
% 3. Modelo de contexto e nós enriquecidos (Ctx e TNode)
% =========================================================
\subsection{Modelo de contexto e nós enriquecidos}

\subsubsection{Contexto de análise \texttt{Ctx}}

% TODO:
%  - Retomar: Ctx = estado global por arquivo.
%  - Explicar os campos principais:
%    * class_stack, func_stack (escopo atual),
%    * lines, comments_by_line (texto do arquivo e índice de comentários),
%    * root_path, file_path (contexto de projeto),
%    * docstrings_by_qname (índice global de docstrings),
%    * scratch (área temporária para cooperação entre passes).

% Se quiser, pode colocar uma pequena tabela nome do campo / descrição.

\subsubsection{Nó sintático enriquecido \texttt{TNode}}

% TODO:
%  - Explicar a ideia geral:
%    * TNode encapsula ast.AST + metadados derivados.
%    * Organizado em blocos temáticos.

\paragraph{Campos estruturais básicos.}

% Aqui você já tem o texto de py_node, lineno, end_lineno.
% TODO:
%  - Explicar que isso ancora o TNode no código-fonte original.

\paragraph{Bloco \emph{path\_info}.}

% Aqui você já tem o texto sobre file_path, rel_path, dir_path, package, module, depth, ext.
% TODO:
%  - Referenciar o pass file_path_info.
%  - Conectar com organização modular do repositório.

\paragraph{Bloco \emph{names\_visibility}.}

% TODO:
%  - Explicar os campos: is_class, is_method, name, qname, decorators, visibility.
%  - Citar que esse bloco é preenchido pelo pass names_visibility.
%  - Comentar a relação com convenções de nomenclatura (prefixos _ / __).

\paragraph{Bloco \emph{naming}.}

% TODO:
%  - Explicar orig_name, name_tokens, naming_style.
%  - Dizer que isso ajuda a transformar nomes em tokens para embeddings.

\paragraph{Bloco \emph{method\_kind}.}

% TODO:
%  - Explicar o campo method_kind e os valores possíveis.
%  - Relacionar com decoradores @staticmethod, @classmethod, @property.

\paragraph{Bloco \emph{io\_signature}.}

% TODO:
%  - Explicar params, return_annotation, is_generator, raises, return_exprs.
%  - Dizer que isso modela a interface de entrada/saída da função/método.

\paragraph{Bloco \emph{class\_kind}.}

% TODO:
%  - Explicar base_classes, metaclass, is_dataclass, is_final, is_enum, class_kind.
%  - Relacionar com a classificação de classes em concrete/abstract/protocol.

\paragraph{Bloco \emph{docs\_comments}.}

% TODO:
%  - Explicar docstring, leading_comment_block, inline_comments.
%  - Ligar com docstrings_by_qname no Ctx.

\paragraph{Bloco de grafo de chamadas.}

% TODO:
%  - Explicar local_callees, callers, callees, fan_in, fan_out.
%  - Comentar que essas métricas são usadas depois na extração de casos de uso.


% =========================================================
% 4. Execução dos passes e pipeline de análise
% =========================================================
\subsection{Execução dos passes e pipeline de análise}

% Aqui você conecta Phase + PassRegistry + walker.

\subsubsection{Fases de execução e registro de passes}

Cada \emph{pass} é implementado como uma função com assinatura padronizada, recebendo o \texttt{TNode} corrente, o nó original da AST (\texttt{ast.AST}) e o contexto de análise (\texttt{Ctx}) e enriquecendo apenas o \texttt{TNode} correspondente. O decorador \texttt{@register\_pass} permite que essa função seja registrada declarativamente junto ao \texttt{PassRegistry}, informando: (i) o nome do \emph{pass} (\texttt{name}); (ii) a fase em que deve ser executado (\texttt{phase}); (iii) uma prioridade relativa (\texttt{order}); (iv) as dependências de outros \emph{passes} (\texttt{requires}); (v) os tipos de nó aos quais se aplica (\texttt{node\_types}); e (vi) os campos do \texttt{TNode} que serão preenchidos (\texttt{provides}).

Durante a inicialização da ferramenta, os módulos de plugins são carregados e seus \emph{passes} são registrados no \texttt{PassRegistry}. Para cada fase (\texttt{PRE}, \texttt{ENRICH}, \texttt{POST}), o núcleo consulta o registrador, obtém a lista de \texttt{PassSpec}s e aplica a ordenação topológica, garantindo que todas as dependências sejam respeitadas. Assim, por exemplo, um \emph{pass} responsável por calcular métricas de grafo de chamadas pode declarar que depende de outro \emph{pass} que constrói as arestas do grafo; o \texttt{PassRegistry} assegura que o primeiro só será executado depois que o segundo tiver produzido os dados necessários.

Esse mecanismo de registro e ordenação por fases permite separar a lógica de enriquecimento do código de infraestrutura de execução. O código cliente precisa apenas escolher quais plugins carregar; a definição da ordem correta de execução é responsabilidade do microkernel de \emph{passes}. Como consequência, novos \emph{passes} podem ser introduzidos ou removidos sem alterar o núcleo, preservando a extensibilidade e a reprodutibilidade dos experimentos.

\subsubsection{Estratégias de travessia e \texttt{walker}}

% TODO:
%  - Descrever como a AST é percorrida:
%    * escolha de estratégia (preorder, bfs, ...),
%    * geração dos TNodes,
%    * laço: para cada fase → para cada nó → rodar passes compatíveis.

% Se quiser, aqui é um bom lugar pra referenciar o diagrama da ordem dos plugins.


% =========================================================
% 5. Passes padrão (documentação um a um)
% =========================================================
\subsection{Passes padrão de enriquecimento}

% Aqui é a parte “catálogo” dos passes builtin, sempre com o mesmo padrão:
% objetivo, campos preenchidos, resumo da lógica, dependências.

\paragraph{\texttt{path\_info}.}

% TODO:
%  - Objetivo.
%  - Campos preenchidos.
%  - Resumo da lógica (já está praticamente pronto em texto).

\paragraph{\texttt{names\_visibility}.}

% TODO:
%  - Objetivo.
%  - Campos preenchidos.
%  - Como usa class_stack/func_stack do Ctx.
%  - Regras de visibilidade.

\paragraph{\texttt{naming}.}

% TODO:
%  - Objetivo (tokenizar nomes e detectar estilo).
%  - Campos preenchidos.
%  - Heurísticas básicas de splitting.

\paragraph{\texttt{method\_kind}.}

% TODO:
%  - Objetivo (distinguir tipos de método).
%  - Campos preenchidos.
%  - Como identifica static/class/property.

\paragraph{\texttt{io\_signature}.}

% TODO:
%  - Objetivo (modelar I/O).
%  - Campos preenchidos.
%  - Como percorre a sub-árvore de função para retornar raises/return_exprs.

\paragraph{\texttt{class\_kind}.}

% TODO:
%  - Objetivo (identificar tipo de classe).
%  - Campos preenchidos.
%  - Critérios para concrete/abstract/protocol.

\paragraph{\texttt{docs\_comments}.}

% TODO:
%  - Objetivo (integrar docstrings e comentários).
%  - Campos preenchidos em TNode.
%  - Atualização de docstrings_by_qname no Ctx.

\paragraph{\texttt{core\_nodes}.}

% TODO:
%  - Objetivo (definir subconjunto “essencial” da AST).
%  - Campos preenchidos (is_core, core_kind).
%  - Quais tipos de nós entram nesse recorte.

\paragraph{\texttt{call\_graph}.}

% TODO:
%  - Objetivo (construir grafo de chamadas e métricas).
%  - Campos preenchidos em duas fases:
%    * ENRICH: local_callees + scratch["call_edges"].
%    * POST: callers, callees, fan_in, fan_out.
%  - Dependência de outros passes, se houver.


% =========================================================
% 6. API de alto nível para análise de repositórios
% =========================================================
\subsection{API de alto nível para análise de repositórios}

% Aqui entra a parte do run_ast_analysis.

% TODO:
%  - Descrever a função run_ast_analysis (entrada: arquivo ou diretório).
%  - Explicar o que é AnalysisResult (mapa de arquivo → {Ctx, lista de TNodes}).
%  - Passos do fluxo:
%    * descobrir arquivos .py,
%    * ler código, coletar comentários, montar Ctx,
%    * parsear AST e chamar walk_module,
%    * retornar estrutura serializável (e opcionalmente exportar para JSON).

% Você pode fechar esta subseção mencionando como esse resultado é consumido:
%  - geração de embeddings,
%  - extração de casos de uso,
%  - etc.


% =========================================================
% 7. Considerações finais sobre a arquitetura
% =========================================================
\subsection{Resumo da arquitetura de análise estática}

% TODO:
%  - 1–2 parágrafos amarrando tudo:
%    * separação núcleo vs plugins,
%    * papel de Ctx/TNode,
%    * papel das fases e passes,
%    * como isso viabiliza os experimentos de Engenharia de Requisitos/LLM.

\newpage
\printbibliography

\end{document}

\newpage

\printbibliography

\end{document}

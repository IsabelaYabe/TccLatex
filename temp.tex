\documentclass[12pt,a4paper]{article}
\usepackage[T1]{fontenc}

% Idioma e tipografia
\usepackage[brazil]{babel}
\usepackage{csquotes}

% Layout e recursos básicos
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bookmark}

% Matemática e teoremas (essencial só se você usa)
\usepackage{amsmath,amssymb,amsthm}

% Bibliografia ABNT numerada
\usepackage[
  backend=biber,
  style=abnt,          % estilo bibliográfico
  sorting=none,
  giveninits=true,
  uniquename=false,
  doi=false,
  isbn=false,
  url=false,
  language=brazil,
  scbib,
  ittitles,
  justify
]{biblatex}
\addbibresource{refs.bib}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{0cm}
        
            \includegraphics[width=0.5\textwidth]{Images/Logo_FGV.png} 
            
        \vspace{1.5cm}
        \large
        
        Ciência de Dados e I.A.\\
        Escola de Matemática Aplicada\\
        Fundação Getúlio Vargas\\

        \vspace{1cm}  
    
        \Large
        Engenharia de Requisitos
            
        \vspace{2cm}
        
        \vspace{0.25cm}

        \Huge \textbf{Proposta de TCC} \\ 
        \vspace{0.5cm}
        \huge \textbf{LLM para Engenharia de Requisitos}
        \vspace{3.6cm}
        
        \large
                Aluno: Isabela Yabe\\
                Orientador: Rafael de Pinho André\\
                Escola de Matemática Aplicada, FGV/EMAp \\
                Rio de Janeiro - RJ.
        \vfill
            
        \vspace{0.8cm}  
        
        Rio de Janeiro, 2025
            
    \end{center}
\end{titlepage}

\newpage
\tableofcontents

\newpage
\section{Proposta de resumo}
Este trabalho propõe uma quarta via para o projeto de software, além das três descritas por Larman — “codificar”, “desenhar-depois-codificar” e “apenas desenhar”: codificar e visualizar. Partimos da engenharia reversa com foco em redocumentação para gerar diagramas de casos de uso diretamente do código-fonte. A abordagem combina (i) uma linguagem abstrata sensível a fluxo de dados e insensível a fluxo de controle, que preserva apenas criações, atribuições e chamadas que propagam referências; (ii) uma AST reduzida que organiza classes, métodos, atributos e instruções; e (iii) análise semântica assistida por LLMs sobre docstrings, comentários e nomenclaturas. No plano de processo, seguimos os princípios de Model-Driven Reverse Engineering: descobrimos um modelo a partir do código (AST/metamodelo) e derivamos visões de alto nível (casos de uso, dependências, generalizações), com rastreabilidade de cada elemento para os trechos de código de origem. Aplicamos o método a três repositórios Python (incluindo a reimplementação do Colossal Cave Adventure), demonstrando a viabilidade da recuperação automática de casos de uso e a utilidade prática dos artefatos produzidos (diagrama, dicionário de vocabulário e mapa de navegação) para compreensão e manutenção. Como limitações, discutimos: identificação de atores ainda predominantemente guiada por evidências textuais; ausência de análise dinâmica; e sensibilidade a nomenclaturas pobres. Os resultados apontam que a estratégia reduz o esforço inicial de entendimento e estabelece uma base padronizada para evolução e auditoria de sistemas legados.

Palavras-chave: engenharia reversa; redocumentação; AST; UML; casos de uso; análise estática; LLM; MDRE.

A ideia é simples: enquanto o desenvolvedor programa, uma ferramenta acoplada ao repositório analisa identificadores, comentários, mensagens e estruturas de código, extrai sinais semânticos por meio de \emph{embeddings} e, com apoio de \emph{LLMs}, \textbf{reconstrói e atualiza casos de uso} em tempo de edição. O resultado é uma visão contínua dos \textbf{atores}, \textbf{objetivos} e \textbf{relacionamentos} (fluxo principal e alternativas), com \emph{rastreabilidade} de volta às linhas de código que motivaram cada passo.

Concretamente, o modo \emph{codificar e visualizar} oferece:
\begin{itemize}
  \item \textbf{Feedback imediato}: geração incremental de casos de uso (texto + diagrama UML) a cada \emph{commit} ou salvamento.
  \item \textbf{Rastreabilidade}: links do caso de uso para trechos de código, testes e mensagens de \emph{commit}.
  \item \textbf{Alinhamento conceptual}: destaque de atores afetados por uma mudança e de requisitos possivelmente impactados.
  \item \textbf{Onboarding acelerado}: documentação inicial sempre atualizada para sistemas com documentação ausente ou obsoleta.
\end{itemize}

Dessa forma, o desenvolvedor mantém, durante a própria codificação, uma visão verificável do comportamento que está implementando, reduzindo o desvio entre \emph{o que} o sistema faz e \emph{para quem} ele faz.

\section{AAAH}

Apesar dessas práticas, a perda de significado ainda é comum em ambientes colaborativos. Avanços recentes em modelos de linguagem e em representações semânticas (embeddings) abrem uma oportunidade: tratar o repositório de código como um corpus rico em sinais de intenção (identificadores, comentários, \emph{docstrings}, \emph{issues}, \emph{commits}). Combinando \emph{embeddings} e \emph{Retrieval-Augmented Generation} (RAG), podemos recuperar e recompor essas intenções em artefatos de engenharia de requisitos.

Este trabalho propõe uma abordagem de \textbf{engenharia reversa orientada por aprendizado de máquina} para \emph{derivar casos de uso} a partir do código-fonte, conectando-o a uma base curada de boas práticas e obras clássicas. Como estudo de caso, analisamos o \emph{Colossal Cave Adventure} (Crowther/Woods), cujo desenho em tabelas facilita a correspondência entre elementos do código, comportamentos observáveis e narrativas de uso. Nossas contribuições são: (i) um método de extração e alinhamento semântico (código → casos de uso), (ii) um \emph{pipeline} RAG reprodutível, e (iii) evidências de que a técnica aumenta a precisão e a compreensibilidade da documentação gerada.


\section{Introdução}

A engenharia de software estuda e avalia métodos capazes de aproximar o código-fonte da linguagem natural. Essa busca se manifesta em duas vertentes complementares: a interação com o usuário final e a comunicação entre os próprios desenvolvedores.

Esse estudo fundamenta-se em autores que defendem o desenvolvimento estruturado e orientado ao usuário, projetado a partir da visão e das necessidades de quem o utiliza, e não apenas da estrutura interna ou das preferências de quem o desenvolve. Essa perspectiva deu origem a princípios de design centrados na função e no comportamento observável do sistema, enfatizando que a organização do código deve refletir a experiência do usuário e os fluxos de interação previstos.

\textcite{yourdon1979structured} descrevem o processo tradicional de desenvolvimento de software como uma cadeia de tradução sucessiva: o diálogo entre o dono do produto (usuário) e o analista é continuamente reinterpretado pelo engenheiro de requisitos, pelo designer e pelo programador. Cada etapa dessa cadeia implica na perda ou distorção de parte do significado original do usuário, o que pode resultar em comportamentos apenas próximos ao desejado. Diante disso, os autores propõem o projeto estruturado, cujo ponto inicial é a clareza e a visibilidade das decisões e atividades envolvidas, promovendo uma compreensão compartilhada e garantindo que o design reflita as intenções originais do sistema.

Problematização

Com o mesmo intuito de tornar o comportamento do sistema visível e compreensível, surge a modelagem de casos de uso como um instrumento de unificação entre requisitos, design e usabilidade. Segundo \textcite{booch1999unified}, nenhum sistema existe isoladamente: todo sistema relevante interage com atores, humanos ou automáticos, que esperam comportamentos previsíveis. O diagrama de casos de uso permite que analistas e desenvolvedores discutam o comportamento do sistema sem se prender aos detalhes da implementação, oferecendo uma linguagem comum e verificável para representar comportamentos.

Autores posteriores ampliaram essa discussão ao nível do código, enfatizando a necessidade de que o código não seja apenas executável, mas também compreensível. Como sintetiza \textcite{fowler2018refactoring}, “qualquer tolo escreve um código que um computador possa entender; bons programadores escrevem código que seres humanos possam entender”.

Entretanto, a legibilidade do código, por si só, não substitui a documentação de requisitos. Enquanto o código explica como o sistema se comporta, a documentação torna explícito por que ele deve se comportar assim. Segundo \textcite{sommerville1997requirements}, a documentação de requisitos atua como um contrato conceitual entre usuários, analistas e desenvolvedores, garantindo o alinhamento entre o comportamento implementado e as expectativas de negócio. Quando essa documentação falta ou envelhece, a legibilidade do código torna-se o principal ponto de apoio para reconstruir as intenções originais — um desafio central na manutenção e evolução de sistemas legados.

Questão e hipótese

Se o código é um texto escrito para ser lido por humanos, então suas palavras, nomes e estruturas carregam pistas úteis sobre o que o sistema faz e para quem. Partindo dessa premissa, questiona-se: é possível reconstruir casos de uso a partir do código-fonte, combinando análise estrutural e interpretação semântica automatizada?

A hipótese deste trabalho é que técnicas de representação semântica, como embeddings e Large Language Models (LLMs), quando aplicadas sobre estruturas abstratas do código — como a Abstract Syntax Tree (AST) — podem permitir a reconstrução de artefatos de alto nível, como diagramas de casos de uso, mesmo na ausência de documentação formal.

Objetivo(s)

O objetivo geral deste trabalho é propor um processo de redocumentação automatizada capaz de gerar diagramas de casos de uso a partir do código-fonte, preservando a semântica do sistema original.
Para isso, o método combina:

a engenharia reversa orientada por modelos (MDRE) descrita por \textcite{Bruneliere2010MoDisco}, que transforma código e artefatos em modelos intermediários por meio das fases de descoberta e compreensão de modelos;

e a representação sintática reduzida proposta por \textcite{tonella2007reverse}, que filtra o código mantendo apenas elementos essenciais ao fluxo de objetos (criações, atribuições e chamadas), descartando instruções de controle.

Essa abordagem é materializada por meio de uma Abstract Syntax Tree (AST), estrutura também empregada por \textcite{pereira2011recovering}, \textcite{Wang2006AST} e \textcite{Fauzi2016AST}, que organiza o sistema de forma hierárquica e independente da sintaxe textual. A AST serve como modelo intermediário entre a estrutura sintática e os diagramas de casos de uso, permitindo representar classes, métodos, atributos e interações de forma compreensível e consistente.

Além da análise estrutural, este trabalho incorpora informações semânticas extraídas diretamente das docstrings, comentários e nomenclaturas do código. Esses elementos são tratados como extensões dos objetos, pois comunicam intenções e relações entre entidades. Com o apoio de LLMs, essas evidências são analisadas de forma contextual, permitindo inferir papéis, objetivos e interações que não estão explicitamente representados nas chamadas ou estruturas do código.

Relevância

A proposta contribui para reduzir o custo e o esforço de redocumentação de sistemas legados, um problema recorrente em ambientes corporativos e de pesquisa, nos quais o código frequentemente sobrevive à sua documentação. Ao unir análise sintática e interpretação semântica assistida por IA, o trabalho visa aproximar o entendimento do sistema à linguagem natural, recuperando a lógica de usabilidade e o comportamento observável do ponto de vista do usuário.

Além disso, o estudo resgata a importância dos casos de uso como ferramenta central na modelagem e comunicação entre equipes de desenvolvimento. Segundo \textcite{larman2002applying}, os casos de uso não apenas documentam funcionalidades, mas representam um instrumento essencial de convergência entre analistas, projetistas e programadores — especialmente em metodologias ágeis, nas quais a documentação deve ser leve, iterativa e centrada no valor entregue ao usuário. Nesses contextos, casos de uso bem definidos auxiliam na priorização de requisitos, na validação de comportamentos e na manutenção de uma visão compartilhada do sistema, mesmo em ambientes de mudança constante.

Embora a maioria dos estudos sobre Model-Driven Reverse Engineering (MDRE) e redocumentação esteja concentrada em linguagens como Java, este trabalho propõe uma abordagem direcionada à linguagem Python — uma escolha relevante tanto pela sua ampla adoção em contextos de ciência de dados e desenvolvimento ágil, quanto pelas diferenças estruturais que desafiam técnicas tradicionais baseadas em tipagem estática. Assim, o estudo amplia o escopo da engenharia reversa orientada a modelos, adaptando suas estratégias a um ecossistema dinâmico e cada vez mais presente em sistemas modernos.

Além de oferecer uma nova aplicação prática de Large Language Models na engenharia de software, o estudo propõe uma ponte entre engenharia de requisitos e engenharia reversa, reforçando a ideia de que compreender um sistema começa por compreender seu código — não apenas como instrução, mas como expressão das intenções humanas que o originaram.

\section{Metodologia de Mapeamento Sistemático}
\subsection{Capítulo 17
CASOS DE USO - UML}
Nenhum sistema existe isoladamente. Todo sistema interessante interage
com atores humanos ou autômatos que utilizam esse sistema para algum propósito e esses atores esperam que o sistema se comporte de acordo com as maneiras previstas. Um caso de uso especifica o comportamento de um sistema ou de
parte de um sistema e é uma descrição de um conjunto de seqüências de ações,
incluindo variantes realizadas pelo sistema para produzir um resultado observável do valor de um ator.
Os casos de usos podem ser aplicados para captar o comportamento pretendido do sistema que está sendo desenvolvido, sem ser necessário especificar
como esse comportamento é implementado. Os casos de uso fornecem uma maneira para os desenvolvedores chegarem a uma compreensão comum com os
usuários finais do sistema e com os especialistas do domínio. Além disso, os casos de uso servem para ajudar a validar a arquitetura e para verificar o sistema à
medida que ele evolui durante seu desenvolvimento. À proporção que você implementa o seu sistema, esses casos de uso são realizados por colaborações cujos
elementos trabalham em conjunto para a execução de cada caso de uso.
Casos de uso bem-estruturados denotam somente o comportamento essencial do sistema ou subsistema e não são amplamente gerais, nem muito específicos.

Um caso de uso executa alguma quantidade tangível de trabalho. Sob a
perspectiva de um determinado ator, um caso de uso realiza algo que é de valor
para um ator, como o cálculo de um resultado, a geração de um novo objeto ou
a modificação do estado de outro objeto. Por exemplo, na modelagem de um
banco, o processamento de um empréstimo resulta na entrega de um empréstimo aprovado, manifestada como uma pilha de dinheiro entregue nas mãos do
cliente.

Você poderá aplicar os casos de uso a todo o seu sistema. Também pode
aplicá-los a uma parte do sistema, incluindo subsistemas e até interfaces e classes
individuais. Em cada situação, os casos de uso não apenas representam o comportamento desejado desses elementos, mas também podem ser utilizados como
a base de casos de teste para esses elementos, à medida que evoluem durante o
desenvolvimento. Casos de uso aplicados aos subsistemas são excelentes fontes
de testes de regressão; casos de uso aplicados a todo o sistema são excelentes
fontes de testes de sistema e de integração. A UML fornece a representação gráfica de um caso de uso e de um ator, conforme mostra a Figura 17.1. Essa notação permite visualizar um caso de uso em separado de sua realização e no contexto com outros casos de uso.
\section{Escolha da linguagem e porque OO}
\section{Escolha de repositório}
\subsection{Colossal Cave Adventure}
“Como qualquer programa significativo, \textit{Adventure} expressava a personalidade e o ambiente de seus autores.” \textcite{levy2010hackers}

Will Crowther e sua ex-esposa, Patricia Crowther, ambos programadores e espeleólogos, participaram do mapeamento do sistema de cavernas de Flint Ridge, na Mammoth Cave, localizada em Kentucky. No verão de 1974, enquanto jogava campanhas de Dungeons and Dragons, Will desenvolveu em Fortran o que viria a ser o primeiro jogo de aventura interativa, originalmente chamado de ADVENT, Colossal Cave Adventure. A jogabilidade baseava-se em comandos de texto digitados pelo jogador, que descreviam ações em um ambiente simulado. O sistema interpretava instruções como “go north”, “take lamp” ou “open door” e retornava descrições das consequências, criando uma interação textual. O mapa utilizado no jogo foi inspirado diretamente nos levantamentos realizados pelo casal durante as expedições à Mammoth Cave, refletindo no código a estrutura real da caverna.

Como o próprio Will Crowther relata, a ideia do jogo surgiu da combinação entre suas experiências em espeleologia e seu interesse por Dungeons and Dragons: “Eu estava envolvido em um jogo de interpretação de papéis... e tive uma ideia que combinasse o meu interesse por exploração de cavernas com algo que também fosse um jogo para as crianças...” \textcite{peterson1983genesis}.

\textcite{levy2010hackers} mostra como inicia a colaboração de Donald Woods em 1976, um pesquisador da \textit{Stanford Artificial Intelligence Laboratory} (SAIL). Woods entrou em contato com Crowther, obteve sua permissão e passou a expandir o código. Sua versão incorporou novos puzzles, criaturas e elementos de fantasia inspirados na obra de Tolkien, além de um sistema de pontuação que estabelecia um objetivo mensurável ao jogador. A versão combinada de Crowther e Woods é um marco na história da interação humano-computador.

Além do arquivos \textcite{adventure_original_sources}, como o jogo não possue documentação técnica original, usaremos o artigo de \textcite{jerz2007colossal} para orientar a análise da portabilidade em Python. O estudo recupera e examina o código Fortran original de Crowther, a partir de um backup do SAIL. Jerz detalha as seis tabelas centrais do código fonte em Fortran: descrições longas, rótulos curtos das salas, dados do mapa, palavras-chave agrupadas do vocabulário, estados estáticos e dicas/eventos. Exatamente o tipo de estrutura que é preservada no versão em Python através do arquivo \texttt{advent.dat}. Permitindo mapear conceitos do Fortran, tabelas, palavras‐chave e transições, para as construções equivalentes no código Python analisado neste trabalho.

\subsection{Código-fonte em Fortran de Crowther}

Conforme analisado por \textcite{jerz2007colossal}, o programa é dividido em dois arquivos principais: um dedicado à lógica e outro aos dados, estes organizados em seis tabelas distintas.

As seis tabelas descritas por Crowther estruturam o mundo do jogo e suas interações:
\begin{enumerate}
    \item \textbf{Long Descriptions}: textos descritivos longos que definem os ambientes e estados narrativos;
    \item \textbf{Short Room Labels}: nomes curtos usados internamente para identificar locais e facilitar a navegação;
    \item \textbf{Map Data}: conexões topológicas entre os ambientes e as direções de movimento possíveis;
    \item \textbf{Grouped Vocabulary Keywords}: agrupamento de palavras-chave e comandos interpretados pelo sistema;
    \item \textbf{Static Game States}: variáveis e condições fixas que controlam a lógica do jogo;
    \item \textbf{Hints and Events}: mensagens de ajuda, eventos dinâmicos e respostas a situações específicas.
\end{enumerate}

\paragraph{Tabela 1 – Long Descriptions.}  
A tabela contém descrições extensas dos ambientes do jogo. Com 302 linhas e 78(confirmar o número no dat) entradas numeradas de -1 a 140, ela define os textos apresentados ao jogador em diferentes locais. Cada linha representa uma sala ou estado narrativo. Parte dessas descrições refere-se diretamente a locais da caverna, como o trecho “\textit{YOU ARE STANDING AT THE END OF A ROAD BEFORE A SMALL BRICK BUILDING}”, enquanto outras descrevem situações de falha ou eventos inesperados, como “\textit{YOU ARE AT THE BOTTOM OF THE PIT WITH A BROKEN NECK}”.  

Exemplos:  
\begin{itemize}
    \item 1	AROUND YOU IS A FOREST.  A SMALL STREAM FLOWS OUT OF THE BUILDING AND
    \item 1	DOWN A GULLY.
    \item 2	YOU HAVE WALKED UP A HILL, STILL IN THE FOREST.  THE ROAD SLOPES BACK
    \item 2	DOWN THE OTHER SIDE OF THE HILL.  THERE IS A BUILDING IN THE DISTANCE.
    \item 3	YOU ARE INSIDE A BUILDING, A WELL HOUSE FOR A LARGE SPRING.
\end{itemize}

\paragraph{Tabela 2 – Short Room Labels.}  
A segunda tabela contém rótulos curtos correspondentes às localizações/ambientes do jogo. 
Com 67 entradas numeradas de 1 a 130, indicando que nem todas as salas ou estados definidos em \textit{Long Descriptions} possuem equivalentes resumidos.  

Exemplos:  
\begin{itemize}
    \item 1 YOU'RE AT END OF ROAD AGAIN.
    \item 3 YOU'RE INSIDE BUILDING.
    \item 18 YOU'RE IN NUGGET OF GOLD ROOM.
    \item 19 YOU'RE IN HALL OF MT KING.
    \item 33 YOU'RE AT Y2.
\end{itemize}


\paragraph{Tabela 3 – Map Data.}
A terceira tabela codifica a topologia do mundo do jogo e as regras de navegação, funcionando como um grafo dirigido rotulado. A primeira coluna indica o ambiente em que o jogador se encontra, a segunda define o ambiente de destino, e as colunas subsequentes agrupam os vocabulários que podem ser utilizados para realizar a transição entre os dois pontos. O mapeamento dos vocabulários é definido na Tabela 4.  

Exemplos:
\begin{itemize}
  \item 1 | 2 | 2 | 44 | 29: o jogador se desloca do ambiente 1 ao aombiente 2, se utilizados os comando 2, 44 ou 29. 
  \item 3 | 1 | 3 | 11 | 32 | 44: o jogador se desloca do ambiente 2 ao ambiente 1 se utilizados os comando 3, 11, 32 ou 44.
\end{itemize}

\paragraph{Tabela 4 – Grouped Vocabulary Keywords.}
No jogo original em Fortran, todo input era trucado nos seus 5 primeiros caracteres, a versão de \textcite{rhodes_adventure_py} aceita inputs de 5 letras ou palavras completas. Por exemplo o comando "inventory" pode ser substituido por "inven". 

A quarta tabela representa o vocabulário reconhecido pelo jogo, funcionando como o léxico central do sistema de interpretação de comandos. Ela contém 193 itens, todos truncados aos cinco primeiros caracteres, e agrupa palavras sinônimas sob o mesmo identificador numérico, permitindo que diferentes entradas do jogador acionem a mesma ação.  

O primeiro grupo, numerado entre~2 e 70, reúne palavras associadas ao movimento. Nessa seção, comandos como \texttt{ENTER}, \texttt{DOOR} e \texttt{GATE} compartilham o identificador~3, sendo tratados como equivalentes. Termos que indicam direções cardeais (\texttt{NORTH}, \texttt{EAST}, \texttt{SOUTH}, \texttt{WEST}) ocupam os números~43–46, enquanto os movimentos verticais (\texttt{UP}, \texttt{DOWN}) aparecem em~29 e 30. Essa codificação evidencia uma transição de um estilo linear de navegação para um modelo espacial baseado em coordenadas, característica que se tornaria definidora do gênero das aventuras de texto.

O segundo grupo, numerado entre~1001 e 1023, abrange objetos e entidades do jogo — tanto itens manipuláveis (como \texttt{KEYS}, \texttt{LAMP}, \texttt{ROD}) quanto elementos de cenário (\texttt{STEPS}, \texttt{GRATE}) e adversários (\texttt{SNAKE}, \texttt{DWARVES}). Alguns objetos compartilham o mesmo código, indicando equivalência funcional: por exemplo, \texttt{BOTTL} e \texttt{WATER} possuem o identificador~1020, sendo tratados como o mesmo objeto.  

O terceiro grupo (prefixo~2000) reúne verbos de ação, incluindo doze sinônimos para “pegar” (\texttt{TAKE}, \texttt{GET}), cinco para “soltar” (\texttt{RELEASE}) e nove para “andar” (\texttt{WALK}). Um agrupamento curioso inclui \texttt{CALM}, \texttt{WAVE}, \texttt{SHAKE}, \texttt{SING} e \texttt{CLEAVE}, todos com o código~2010 — indicando um mapeamento genérico de gestos ou interações sociais.  

A análise da Tabela 4 revela ainda que o código original de Crowther não possuía comandos para salvar o jogo, verificar o placar ou listar o inventário, funções que só seriam adicionadas por Don Woods em sua expansão posterior. O último termo adicionado ao vocabulário é um palavrão de quatro letras, indício de que Crowther testava também respostas a comandos improváveis de jogadores frustrados — uma evidência da natureza experimental e humorada do projeto.  

Essa estrutura lexical demonstra uma clara separação entre a camada de linguagem (Tabela 4) e a lógica de jogo (Tabela 3), antecipando princípios modernos de design modular e interpretadores baseados em dicionários.

\newpage

\printbibliography

\end{document}